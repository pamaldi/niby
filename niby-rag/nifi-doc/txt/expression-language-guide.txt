Apache NiFi Expression Language Guide

Apache NiFi Expression Language Guide

 Apache NiFi Team 
 dev@nifi.apache.org 
 Table of Contents • Overview • Structure of a NiFi Expression • Expression Language Hierarchy • Expression Language in the Application • Escaping Expression Language • Expression Language Editor • Framework System Properties • Functions • Data Types • Boolean Logic • isNull • notNull • isEmpty • equals • equalsIgnoreCase • gt • ge • lt • le • and • or • not • ifElse • isJson • String Manipulation • toUpper • toLower • trim • substring • substringBefore • substringBeforeLast • substringAfter • substringAfterLast • getDelimitedField • append • prepend • replace • replaceFirst • replaceAll • padLeft • padRight • replaceNull • replaceEmpty • length • evaluateELString • repeat • replaceByPattern • Encode/Decode Functions • escapeJson • escapeXml • escapeCsv • escapeHtml3 • escapeHtml4 • unescapeJson • unescapeXml • unescapeCsv • unescapeHtml3 • unescapeHtml4 • urlEncode • urlDecode • base64Encode • base64Decode • UUID3 • UUID5 • hash • Searching • startsWith • endsWith • contains • in • find • matches • indexOf • lastIndexOf • jsonPath • jsonPathDelete • jsonPathAdd • jsonPathSet • jsonPathPut • Mathematical Operations and Numeric Manipulation • plus • minus • multiply • divide • mod • toRadix • fromRadix • random • math • Date Manipulation • format • formatInstant • toDate • toInstant • toMicros • toNanos • now • Type Coercion • toString • toNumber • toDecimal • Subjectless Functions • ip • hostname • UUID • nextInt • literal • getStateValue • thread • getUri • Evaluating Multiple Attributes • anyAttribute • allAttributes • anyMatchingAttribute • allMatchingAttributes • anyDelineatedValue • allDelineatedValues • join • count Overview

 All data in Apache NiFi is represented by an abstraction called a FlowFile. A FlowFile is comprised of two major pieces: content and attributes. The content portion of the FlowFile represents the data on which to operate. For instance, if a file is picked up from a local file system using the GetFile Processor, the contents of the file will become the contents of the FlowFile.

 The attributes portion of the FlowFile represents information about the data itself, or metadata. Attributes are key-value pairs that represent what is known about the data as well as information that is useful for routing and processing the data appropriately. Keeping with the example of a file that is picked up from a local file system, the FlowFile would have an attribute called filename that reflected the name of the file on the file system. Additionally, the FlowFile will have a path attribute that reflects the directory on the file system that this file lived in. The FlowFile will also have an attribute named uuid, which is a unique identifier for this FlowFile. For complete listing of the core attributes check out the FlowFile section of the Developer’s Guide.

 However, placing these attributes on a FlowFile do not provide much benefit if the user is unable to make use of them. The NiFi Expression Language provides the ability to reference these attributes, compare them to other values, and manipulate their values.

 Structure of a NiFi Expression

 The NiFi Expression Language always begins with the start delimiter ${ and ends with the end delimiter }. Between the start and end delimiters is the text of the Expression itself. In its most basic form, the Expression can consist of just an attribute name. For example, ${filename} will return the value of the filename attribute.

 In a slightly more complex example, we can instead return a manipulation of this value. We can, for example, return an all upper-case version of the filename by calling the toUpper function: ${filename:toUpper()}. In this case, we reference the filename attribute and then manipulate this value by using the toUpper function. A function call consists of 5 elements. First, there is a function call delimiter :. Second is the name of the function - in this case, toUpper. Next is an open parenthesis ((), followed by the function arguments. The arguments necessary are dependent upon which function is being called. In this example, we are using the toUpper function, which does not have any arguments, so this element is omitted. Finally, the closing parenthesis ()) indicates the end of the function call. There are many different functions that are supported by the Expression Language to achieve many different goals. Some functions provide String (text) manipulation, such as the toUpper function. Others, such as the equals and matches functions, provide comparison functionality. Functions also exist for manipulating dates and times and for performing mathematical operations. Each of these functions is described below, in the Functions section, with an explanation of what the function does, the arguments that it requires, and the type of information that it returns.

 When we perform a function call on an attribute, as above, we refer to the attribute as the subject of the function, as the attribute is the entity on which the function is operating. We can then chain together multiple function calls, where the return value of the first function becomes the subject of the second function and its return value becomes the subject of the third function and so on. Continuing with our example, we can chain together multiple functions by using the expression ${filename:toUpper():equals('HELLO.TXT')}. There is no limit to the number of functions that can be chained together.

 Any FlowFile attribute can be referenced using the Expression Language. However, if the attribute name contains a "special character", the attribute name must be escaped by quoting it. The following characters are each considered "special characters":

 • $ (dollar sign)

 • | (pipe)

 • { (open brace)

 • } (close brace)

 • ( (open parenthesis)

 • ) (close parenthesis)

 • [ (open bracket)

 • ] (close bracket)

 • , (comma)

 • : (colon)

 • ; (semicolon)

 • / (forward slash)

 • * (asterisk)

 • ' (single quote)

 • (space)

 • \t (tab)

 • \r (carriage return)

 • 
 (new-line)

 Additionally, a number is considered a "special character" if it is the first character of the attribute name. If any of these special characters is present in an attribute is quoted by using either single or double quotes. The Expression Language allows single quotes and double quotes to be used interchangeably. For example, the following can be used to escape an attribute named my attribute: ${"my attribute"} or ${'my attribute'}.

 In this example, the value to be returned is the value of the "my attribute" attribute, if it exists. The Expression Language will search through a hierarchy for a matching property. See Expression Language Hierarchy for a description of the hierarchy.

 There also exist some functions that expect to have no subject. These functions are invoked simply by calling the function at the beginning of the Expression, such as ${hostname()}. These functions can then be changed together, as well. For example, ${hostname():toUpper()}. Attempting to evaluate the function with subject will result in an error. In the Functions section below, these functions will clearly indicate in their descriptions that they do not require a subject.

 Often times, we will need to compare the values of two different attributes to each other. We are able to accomplish this by using embedded Expressions. We can, for example, check if the filename attribute is the same as the uuid attribute: ${filename:equals( ${uuid} )}. Notice here, also, that we have a space between the opening parenthesis for the equals method and the embedded Expression. This is not necessary and does not affect how the Expression is evaluated in any way. Rather, it is intended to make the Expression easier to read. White space is ignored by the Expression Language between delimiters. Therefore, we can use the Expression ${ filename : equals(${ uuid}) } or ${filename:equals(${uuid})} and both Expressions mean the same thing. We cannot, however, use ${file name:equals(${uuid})}, because this results in file and name being interpreted as different tokens, rather than a single token, filename.

 Expression Language Hierarchy

 When using Expression Language to reference a property by name there is a defined hierarchy within which NiFi will search for the value.

 The current hierarchy in NiFi is as follows:

 • Search FlowFile for attribute/key

 • Search NiFi JVM Properties for attribute/key

 • Search System Environment Variables for attribute/key

 NiFi will search for, and return, the first occurrence of a matching property. If no matching property is found, null is returned.

 Expression Language in the Application

 The Expression Language is used heavily throughout the NiFi application for configuring Processor properties. Not all Processor properties support the Expression Language, however. Whether or not a Property supports the Expression Language is determined by the developer of the Processor when the Processor is written. However, the application strives to clearly illustrate for each Property whether or not the Expression Language is supported.

 In the application, when configuring a component property, the User Interface provides an Information icon ( ) next to the name of the Property. Hovering over this icon with the mouse will provide a tooltip that provides helpful information about the Property. This information includes a description of the Property, the default value (if any), historically configured values (if any), and the evaluation scope of this property for expression language. There are three values and the evaluation scope of the expression language is hierarchical: NONE → ENVIRONMENT → FLOWFILE_ATTRIBUTES.

 • NONE - expression language is not supported for this property

 • ENVIRONMENT - will use environment variables defined at JVM level and system properties.

 • FLOWFILE_ATTRIBUTES - will use attributes of each individual flow file, as well as those variables defined by the Environment, as described above.

 Escaping Expression Language

 There may be times when a property supports Expression Language, but the user wishes to use a literal value that follows the same syntax as the Expression Language. For example, a user may want to configure a property value to be the literal text Hello ${UserName}. In such a case, this can be accomplished by using an extra $ (dollar sign symbol) just before the expression to escape it (i.e., Hello $${UserName}). Unless the $ character is being used to escape an Expression, it should not be escaped. For example, the value Hello $$User$$Name should not escape the $ characters, so the literal value that will be used is Hello $$User$$Name.

 If more than two $ characters are encountered sequentially before a {, then each pair of $ characters will be considered an escaping of the $ character. The escaping will be performed from left-to-right. To help illustrate this, consider that the variable abc contains the value xyz. Then, consider the following table of Expressions and their corresponding evaluated values:

 Table 1. Escaping EL Examples Expression

 | Value

 | Notes

 | 
 ${abc}

 | xyz

 | | 
 $${abc}

 | ${abc}

 | | 
 $$${abc}

 | $xyz

 | | 
 $$$${abc}

 | $${abc}

 | | 
 $$$$${abc}

 | $$xyz

 | | 
 I owe you $5

 | I owe you $5

 | No actual Expression is present here.

 | 
 You owe me $$5 too

 | You owe me $$5 too

 | The $ character is not escaped because it does not immediately precede an Expression.

 | 
 Unescaped $$${5 because no closing brace

 | Unescaped $$${5 because no closing brace

 | Because there is no closing brace here, there is no actual Expression and hence the $ characters are not escaped.

 | 
 Unescaped $$${5} because no closing brace

 | <Error>

 | This expression is not valid because it equates to an escaped $, followed by ${5} and the ${5} is not a valid Expression. The number must be escaped.

 | 
 Unescaped $$${'5'} because no closing brace

 | Unescaped $ because no closing brace

 | There is no attribute named 5 so the Expression evaluates to an empty string. The $$ evaluates to a single (escaped) $ because it immediately precedes an Expression.

 | 
 Expression Language Editor

 When configuring the value of a Processor property, the NiFi User Interface provides help with the Expression Language using the Expression Language editor. Once an Expression is begin by typing ${, the editor begins to highlight parentheses and braces so that the user is easily able to tell which opening parenthesis or brace matches which closing parenthesis or brace.

 The editor also supplies context-sensitive help by providing a list of all functions that can be used at the current cursor position. To activate this feature, press Ctrl+Space on the keyboard. The user is also able to type part of a function name and then press Ctrl+Space to see all functions that can be used that start with the same prefix. For example, if we type into the editor ${filename:to and then press Ctrl+Space, we are provided a pop-up that lists six different functions: toDate, toLower, toNumber, toRadix, toString, and toUpper. We can then continue typing to narrow which functions are shown, or we can select one of the functions from the list by double-clicking it with the mouse or using the arrow keys to highlight the desired function and pressing Enter.

 Framework System Properties

 The following system properties are set by the NiFi application, and are available to the Expression Language:

 • nifi.framework.version: The build version for the NiFi framework. Usage: ${'nifi.framework.version'}

 Functions

 Functions provide a convenient way to manipulate and compare values of attributes. The Expression Language provides many different functions to meet the needs of a automated dataflow. Each function takes zero or more arguments and returns a single value. These functions can then be chained together to create powerful Expressions to evaluate conditions and manipulate values. See Structure of a NiFi Expression for more information on how to call and chain functions together.

 Data Types

 Each argument to a function and each value returned from a function has a specific data type. The Expression Language supports four different data types:

 • String: A String is a sequence of characters that can consist of numbers, letters, white space, and special characters.

 • Number: A Number is an whole number comprised of one or more digits (0 through 9). When converting to numbers from Date data types, they are represented as the number of milliseconds since midnight GMT on January 1, 1970.

 • Decimal: A Decimal is a numeric value that can support decimals and larger values with minimal loss of precision. More precisely it is a double-precision 64-bit IEEE 754 floating point. Due to this minimal loss of precision this data type should not be used for very precise values, such as currency. For more documentation on the range of values stored in this data type refer to this link. The following are some examples of the forms of literal decimals that are supported in expression language (the "E" can also be lower-case):

 • 1.1

 • .1E1

 • 1.11E-12

 • Date: A Date is an object that holds a Date and Time. Utilizing the Date Manipulation and Type Coercion functions this data type can be converted to/from Strings and numbers. If the whole Expression Language expression is evaluated to be a date then it will be converted to a String with the format: "<Day of Week> <Month> <Day of Month> <Hour>:<Minute>:<Second> <Time Zone> <Year>". Also expressed as "E MMM dd HH:mm:ss z yyyy" in Java DateTimeFormatter format. For example: "Wed Dec 31 12:00:04 UTC 2016".

 • Boolean: A Boolean is one of either true or false.

 After evaluating expression language functions, all attributes are stored as type String.

 The Expression Language is generally able to automatically coerce a value of one data type to the appropriate data type for a function. However, functions do exist to manually coerce a value into a specific data type. See the Type Coercion section for more information.

 Hex values are supported for Number and Decimal types but they must be quoted and prepended with "0x" when being interpreted as literals. For example these two expressions are valid (without the quotes or "0x" the expression would fail to run properly):

 • ${literal("0xF"):toNumber()}

 • ${literal("0xF.Fp10"):toDecimal()}

 Boolean Logic

 One of the most powerful features of the Expression Language is the ability to compare an attribute value against some other value. This is used often, for example, to configure how a Processor should route data. The following functions are used for performing boolean logic, such as comparing two values. Each of these functions are designed to work on values of type Boolean.

 isNull

 Description: The isNull function returns true if the subject is null, false otherwise. This is typically used to determine if an attribute exists.

 Subject Type: Any

 Arguments: No arguments

 Return Type: Boolean

 Examples: ${filename:isNull()} returns true if the "filename" attribute does not exist. It returns false if the attribute exists.

 notNull

 Description: The notNull function returns the opposite value of the isNull function. That is, it will return true if the subject exists and false otherwise.

 Subject Type: Any

 Arguments: No arguments

 Return Type: Boolean

 Examples: ${filename:notNull()} returns true if the "filename" attribute exists. It returns false if the attribute does not exist.

 isEmpty

 Description: The isEmpty function returns true if the Subject is null, does not contain any characters or contains only white-space (new line, carriage return, space, tab), false otherwise.

 Subject Type: String

 Arguments: No arguments

 Return Type: Boolean

 Examples: ${filename:isEmpty()} returns true if the "filename" attribute does not exist or contains only white space. ${literal(" "):isEmpty()} returns true as well as ${literal(""):isEmpty()}.

 equals

 Description: The equals function is very widely used and determines if its subject is equal to another String value. Note that the equals function performs a direct comparison of two String values. Take care not to confuse this function with the matches function, which evaluates its subject against a Regular Expression.

 Subject Type: Any

 Arguments:

 • value : The value to compare the Subject to. Must be same type as the Subject.

 Return Type: Boolean

 Examples: We can check if the filename of a FlowFile is "hello.txt" by using the expression ${filename:equals('hello.txt')}, or we could check if the value of the attribute hello is equal to the value of the filename attribute: ${hello:equals( ${filename} )}.

 equalsIgnoreCase

 Description: Similar to the equals function, the equalsIgnoreCase function compares its subject against a String value but returns true if the two values differ only by case (upper case vs. lower case).

 Subject Type: String

 Arguments:

 • value : The value to compare the Subject to.

 Return Type: Boolean

 Examples: ${filename:equalsIgnoreCase('hello.txt')} will evaluate to true if filename is equal to "hello.txt" or "HELLO.TXT" or "HeLLo.TxT".

 gt

 Description: The gt function is used for numeric comparison and returns true if the subject is Greater Than its argument. If either the subject or the argument cannot be coerced into a Number, this function returns false.

 Subject Type: Number

 Arguments:

 • value : The number to compare the Subject to.

 Return Type: Boolean

 Examples: ${fileSize:gt( 1024 )} will return true if the size of the FlowFile’s content is more than 1 kilobyte (1024 bytes). Otherwise, it will return false.

 ge

 Description: The ge function is used for numeric comparison and returns true if the subject is Greater Than Or Equal To its argument. If either the subject or the argument cannot be coerced into a Number, this function returns false.

 Subject Type: Number

 Arguments:

 • value : The number to compare the Subject to.

 Return Type: Boolean

 Examples: ${fileSize:ge( 1024 )} will return true if the size of the FlowFile’s content is at least ( is greater than or equal to) 1 kilobyte (1024 bytes). Otherwise, it will return false.

 lt

 Description: The lt function is used for numeric comparison and returns true if the subject is Less Than its argument. If either the subject or the argument cannot be coerced into a Number, this function returns false.

 Subject Type: Number

 Arguments:

 • value : The number to compare the Subject to.

 Return Type: Boolean

 Examples: ${fileSize:lt( 1048576 )} will return true if the size of the FlowFile’s content is less than 1 megabyte (1048576 bytes). Otherwise, it will return false.

 le

 Description: The le function is used for numeric comparison and returns true if the subject is Less Than Or Equal To its argument. If either the subject or the argument cannot be coerced into a Number, this function returns false.

 Subject Type: Number

 Arguments:

 • value : The number to compare the Subject to.

 Return Type: Boolean

 Examples: ${fileSize:le( 1048576 )} will return true if the size of the FlowFile’s content is at most (less than or equal to) 1 megabyte (1048576 bytes). Otherwise, it will return false.

 and

 Description: The and function takes as a single argument a Boolean value and returns true if both the Subject and the argument are true. If either the subject or the argument is false or cannot be coerced into a Boolean, the function returns false. Typically, this is used with an embedded Expression as the argument.

 Subject Type: Boolean

 Arguments:

 • condition : The right-hand-side of the 'and' Expression

 Return Type: Boolean

 Examples: We can check if the filename is both all lower-case and has at least 5 characters by using the Expression

 ${filename:toLower():equals( ${filename} ):and(
	${filename:length():ge(5)}
)} or

 Description: The or function takes as a single argument a Boolean value and returns true if either the Subject or the argument is true. If both the subject and the argument are false, the function returns false. If either the Subject or the argument cannot be coerced into a Boolean value, this function will return false.

 Subject Type: Boolean

 Arguments:

 • condition : The right-hand-side of the 'and' Expression

 Return Type: Boolean

 Examples: The following example will return true if either the filename has exactly 5 characters or if the filename is all lower-case.

 ${filename:toLower():equals( ${filename} ):or(
	${filename:length():equals(5)}
)} not

 Description: The not function returns the negation of the Boolean value of the subject.

 Subject Type: Boolean

 Arguments: No arguments

 Return Type: Boolean

 Examples: We can invert the value of another function by using the not function, as ${filename:equals('hello.txt'):not()}. This will return true if the filename is NOT equal to "hello.txt" and will return false if the filename is "hello.txt."

 ifElse

 Description: Evaluates the first argument if the Subject evaluates to true, or the second argument if the Subject evaluates to false.

 Subject Type: Boolean

 Arguments:

 • EvaluateIfTrue : The value to return if the Subject is true

 • EvaluateIfFalse : The value to return if the Subject is false

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", the "nullFilename" attribute has the value null, and the "bool" attribute has the value "true", then the following expressions will provide the following results:

 Table 2. ifElse Examples Expression

 | Value

 | 
 ${bool:ifElse('a','b')}

 | a

 | 
 ${literal(true):ifElse('a','b')}

 | a

 | 
 ${nullFilename:isNull():ifElse('file does not exist', 'located file')}

 | file does not exist

 | 
 ${nullFilename:ifElse('found', 'not_found')}

 | not_found

 | 
 ${filename:ifElse('found', 'not_found')}

 | not_found

 | 
 ${filename:isNull():not():ifElse('found', 'not_found')}

 | found

 | 
 isJson

 Description: [.description]#The isJson function returns true if the subject is a JSON array or a JSON object, false otherwise. This is typically used to determine whether an attribute is JSON in order to allow for a follow-on JSONPath query. Although technically there are other valid JSON types such as string, number, boolean and null, this method is only concerned with the primary JSON objects queried with JSONPath , arrays and objects. #

 Subject Type: Any

 Arguments: No arguments

 Return Type: Boolean

 Examples: If the attribute "jsonObj" has the value {"name":"John", "age":30, "car":null}, the attribute jsonObjMissingStartingBrace has the value "name":"John", "age":30, "car":null}, the attribute jsonObjMissingEndingBrace has the value {"name":"John", "age":30, "car":null, the attribute "jsonArray" has the value ["Ford", "BMW", "Fiat"], the attribute jsonArrayMissingStartingBracket has the value "Ford", "BMW", "Fiat"], the attribute jsonArrayMissingEndingBracket has the value ["Ford", "BMW", "Fiat", the "someAttribute" attribute does not exist, the "emptyQuotedString" attribute value is "", the attribute "quotedString" has the value "someString", the attribute "integer" has the value 1234, the attribute "decimal" has the value 18.36, the attribute "trueAttr" has the value true, the attribute "falseAttr" has the value false and the "nullAttr" attribute has the value null, then the following expressions will provide the following results:

 Table 3. isJson Examples Expression

 | Value

 | 
 ${jsonObj:isJson()}

 | true

 | 
 ${jsonObjMissingStartingBrace:isJson()}

 | false

 | 
 ${jsonObjMissingEndingBrace:isJson()}

 | false

 | 
 ${jsonArray:isJson()}

 | true

 | 
 ${jsonArrayMissingStartingBracket:isJson()}

 | false

 | 
 ${jsonArrayMissingEndingBracket:isJson()}

 | false

 | 
 ${someAttribute:isJson()}

 | false

 | 
 ${emptyQuotedString:isJson())

 | false

 | 
 ${quotedString:isJson()}

 | false

 | 
 ${integer:isJson()}

 | false

 | 
 ${decimal:isJson()}

 | false

 | 
 ${trueAttr:isJson()}

 | false

 | 
 ${falseAttr:isJson()}

 | false

 | 
 ${nullAttr:isJson()}

 | false

 | 
 String Manipulation

 Each of the following functions manipulates a String in some way.

 toUpper

 Description: This function converts the Subject into an all upper-case String. Said another way, it replaces any lowercase letter with the uppercase equivalent.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "filename" attribute is "abc123.txt", then the Expression ${filename:toUpper()} will return "ABC123.TXT"

 toLower

 Description: This function converts the Subject into an all lower-case String. Said another way, it replaces any uppercase letter with the lowercase equivalent.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "filename" attribute is "ABC123.TXT", then the Expression ${filename:toLower()} will return "abc123.txt"

 trim

 Description: The trim function will remove any leading or trailing white space from its subject.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the attribute attr has the value " 1 2 3 ", then the Expression ${attr:trim()} will return the value "1 2 3".

 substring

 Description: Returns a portion of the Subject, given a starting index and an optional ending index. If the ending index is not supplied, it will return the portion of the Subject starting at the given 'start index' and ending at the end of the Subject value.

 The starting index and ending index are zero-based. That is, the first character is referenced by using the value 0, not 1.

 If either the starting index is or the ending index is not a number, this function call will result in an error.

 If the starting index is larger than the ending index, this function call will result in an error.

 If the starting index or the ending index is greater than the length of the Subject or has a value less than 0, this function call will return an empty string.

 Subject Type: String

 Arguments:

 • starting index : The 0-based index of the first character to capture (inclusive)

 • ending index : The 0-based index of the last character to capture (exclusive)

 Return Type: String

 Examples:

 If we have an attribute named "filename" with the value "a brand new filename.txt", then the following Expressions will result in the following values:

 Table 4. Substring Examples Expression

 | Value

 | 
 ${filename:substring(0,1)}

 | a

 | 
 ${filename:substring(2)}

 | brand new filename.txt

 | 
 ${filename:substring(12)}

 | filename.txt

 | 
 ${filename:substring( ${filename:length():minus(2)} )}

 | xt

 | 
 substringBefore

 Description: Returns a portion of the Subject, starting with the first character of the Subject and ending with the character immediately before the first occurrence of the argument. If the argument is not present in the Subject, the entire Subject will be returned.

 Subject Type: String

 Arguments:

 • value : The String to search for in the Subject

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will result in the following values:

 Table 5. SubstringBefore Examples Expression

 | Value

 | 
 ${filename:substringBefore('.')}

 | a brand new filename

 | 
 ${filename:substringBefore(' ')}

 | a

 | 
 ${filename:substringBefore(' n')}

 | a brand

 | 
 ${filename:substringBefore('missing')}

 | a brand new filename.txt

 | 
 substringBeforeLast

 Description: Returns a portion of the Subject, starting with the first character of the Subject and ending with the character immediately before the last occurrence of the argument. If the argument is not present in the Subject, the entire Subject will be returned.

 Subject Type: String

 Arguments:

 • value : The String to search for in the Subject

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will result in the following values:

 Table 6. SubstringBeforeLast Examples Expression

 | Value

 | 
 ${filename:substringBeforeLast('.')}

 | a brand new filename

 | 
 ${filename:substringBeforeLast(' ')}

 | a brand new

 | 
 ${filename:substringBeforeLast(' n')}

 | a brand

 | 
 ${filename:substringBeforeLast('missing')}

 | a brand new filename.txt

 | 
 substringAfter

 Description: Returns a portion of the Subject, starting with the character immediately after the first occurrence of the argument and extending to the end of the Subject. If the argument is not present in the Subject, the entire Subject will be returned.

 Subject Type: String

 Arguments:

 • value : The String to search for in the Subject

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will result in the following values:

 Table 7. SubstringAfter Examples Expression

 | Value

 | 
 ${filename:substringAfter('.')}

 | txt

 | 
 ${filename:substringAfter(' ')}

 | brand new filename.txt

 | 
 ${filename:substringAfter(' n')}

 | ew filename.txt

 | 
 ${filename:substringAfter('missing')}

 | a brand new filename.txt

 | 
 substringAfterLast

 Description: Returns a portion of the Subject, starting with the character immediately after the last occurrence of the argument and extending to the end of the Subject. If the argument is not present in the Subject, the entire Subject will be returned.

 Subject Type: String

 Arguments:

 • value : The String to search for in the Subject

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will result in the following values:

 Table 8. SubstringAfterLast Examples Expression

 | Value

 | 
 ${filename:substringAfterLast('.')}

 | txt

 | 
 ${filename:substringAfterLast(' ')}

 | filename.txt

 | 
 ${filename:substringAfterLast(' n')}

 | ew filename.txt

 | 
 ${filename:substringAfterLast('missing')}

 | a brand new filename.txt

 | 
 getDelimitedField

 Description: Parses the Subject as a delimited line of text and returns just a single field from that delimited text.

 Subject Type: String

 Arguments:

 • index : The index of the field to return. A value of 1 will return the first field, a value of 2 will return the second field, and so on.

 • delimiter : Optional argument that provides the character to use as a field separator. If not specified, a comma will be used. This value must be exactly 1 character.

 • quoteChar : Optional argument that provides the character that can be used to quote values so that the delimiter can be used within a single field. If not specified, a double-quote (") will be used. This value must be exactly 1 character.

 • escapeChar : Optional argument that provides the character that can be used to escape the Quote Character or the Delimiter within a field. If not specified, a backslash (\) is used. This value must be exactly 1 character.

 • stripChars : Optional argument that specifies whether or not quote characters and escape characters should be stripped. For example, if we have a field value "1, 2, 3" and this value is true, we will get the value 1, 2, 3, but if this value is false, we will get the value "1, 2, 3" with the quotes. The default value is false. This value must be either true or false.

 Return Type: String

 Examples: If the "line" attribute contains the value "Jacobson, John", 32, Mr. and the "altLine" attribute contains the value Jacobson, John|32|Mr. then the following Expressions will result in the following values:

 Table 9. GetDelimitedField Examples Expression

 | Value

 | 
 ${line:getDelimitedField(2)}

 | _(space)_32

 | 
 ${line:getDelimitedField(2):trim()}

 | 32

 | 
 ${line:getDelimitedField(1)}

 | "Jacobson, John"

 | 
 ${line:getDelimitedField(1, ',', '"', '\\', true)}

 | Jacobson, John

 | 
 ${altLine:getDelimitedField(1, '|')}

 | Jacobson, John

 | 
 append

 Description: The append function returns the result of appending the argument to the value of the Subject. If the Subject is null, returns the argument itself.

 Subject Type: String

 Arguments:

 • value : The String to append to the end of the Subject

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the Expression ${filename:append('.gz')} will return "a brand new filename.txt.gz".

 prepend

 Description: The prepend function returns the result of prepending the argument to the value of the Subject. If the subject is null, returns the argument itself.

 Subject Type: String

 Arguments:

 • value : The String to prepend to the beginning of the Subject

 Return Type: String

 Examples: If the "filename" attribute has the value "filename.txt", then the Expression ${filename:prepend('a brand new ')} will return "a brand new filename.txt".

 replace

 Description: Replaces all occurrences of one literal String within the Subject with another String.

 Subject Type: String

 Arguments:

 • Search String : The String to find within the Subject

 • Replacement : The value to replace Search String with

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will provide the following results:

 Table 10. Replace Examples Expression

 | Value

 | 
 ${filename:replace('.', '_')}

 | a brand new filename_txt

 | 
 ${filename:replace(' ', '.')}

 | a.brand.new.filename.txt

 | 
 ${filename:replace('XYZ', 'ZZZ')}

 | a brand new filename.txt

 | 
 ${filename:replace('filename', 'book')}

 | a brand new book.txt

 | 
 replaceFirst

 Description: Replaces the first occurrence of one literal String or regular expression within the Subject with another String.

 Subject Type: String

 Arguments:

 • Search String : The String (literal or regular expression pattern) to find within the Subject

 • Replacement : The value to replace Search String with

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will provide the following results:

 Table 11. ReplaceFirst Examples Expression

 | Value

 | 
 ${filename:replaceFirst('a', 'the')}

 | the brand new filename.txt

 | 
 ${filename:replaceFirst('[br]', 'g')}

 | a grand new filename.txt

 | 
 ${filename:replaceFirst('XYZ', 'ZZZ')}

 | a brand new filename.txt

 | 
 ${filename:replaceFirst('\w{8}', 'book')}

 | a brand new book.txt

 | 
 replaceAll

 Description: The replaceAll function takes two String arguments: a literal String or Regular Expression (NiFi uses the Java Pattern syntax), and a replacement string. The return value is the result of substituting the replacement string for all patterns within the Subject that match the Regular Expression.

 Subject Type: String

 Arguments:

 • Regex : The Regular Expression (in Java syntax) to match in the Subject

 • Replacement : The value to use for replacing matches in the Subject. If the regular expression argument uses Capturing Groups, back references are allowed in the replacement.

 Return Type: String

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will provide the following results:

 Table 12. ReplaceAll Examples Expression

 | Value

 | 
 ${filename:replaceAll('\..*', '')}

 | a brand new filename

 | 
 ${filename:replaceAll('a brand (new)', '$1')}

 | new filename.txt

 | 
 ${filename:replaceAll('XYZ', 'ZZZ')}

 | a brand new filename.txt

 | 
 ${filename:replaceAll('brand (new)', 'somewhat $1')}

 | a somewhat new filename.txt

 | 
 padLeft

 Description: The padLeft function prepends the given padding string (or '_', if nothing is provided) to the argument String until the passed desired length is reached.

 It returns the argument as is if its length is already equal or higher than the desired length, if the padding string is null, and if the desired length is either negative or greater than Integer.MAX_VALUE. It returns null if the argument string is not a valid attribute.

 Subject Type: String

 Arguments:

 • DesiredLength : The integer value to pad to.

 • PaddingString : The optional string to pad with. "_" will be used if a PaddingString is not provided. If the PaddingString is not an exact multiple of the actual pad size, it will be trimmed to fit in DesiredLength.

 Return Type: String

 Examples: If the "greetings" attribute has the value "hello", then the following Expressions will provide the following results:

 Table 13. PadLeft Examples Expression

 | Value

 | 
 ${greetings:padLeft(10)}

 | _____hello

 | 
 ${greetings:padLeft(10, '@')}

 | @@@@@hello

 | 
 ${greetings:padLeft(10, 'xy')}

 | xyxyxhello

 | 
 ${greetings:padLeft(10, 'aVeryLongPaddingString')}

 | aVeryhello

 | 
 padRight

 Description: The padRight function appends the given padding string (or '_', if nothing is provided) to the argument String until the passed desired length is reached.

 It returns the argument as is if its length is already equal or higher than the desired length, if the padding string is null, and if the desired length is either negative or greater than Integer.MAX_VALUE. It returns null if the argument string is not a valid attribute.

 Subject Type: String

 Arguments:

 • DesiredLength : The integer value to pad to.

 • PaddingString : The optional string to pad with. "_" will be used if a PaddingString is not provided. If the PaddingString is not an exact multiple of the actual pad size, it will be trimmed to fit in DesiredLength.

 Return Type: String

 Examples: If the "greetings" attribute has the value "hello", then the following Expressions will provide the following results:

 Table 14. PadRight Examples Expression

 | Value

 | 
 ${greetings:padRight(10)}

 | hello_____

 | 
 ${greetings:padRight(10, '@')}

 | hello@@@@@

 | 
 ${greetings:padRight(10, 'xy')}

 | helloxyxyx

 | 
 ${greetings:padRight(10, 'aVeryLongPaddingString')}

 | helloaVery

 | 
 replaceNull

 Description: The replaceNull function returns the argument if the Subject is null. Otherwise, returns the Subject.

 Subject Type: Any

 Arguments:

 • Replacement : The value to return if the Subject is null.

 Return Type: Type of Subject if Subject is not null; else, type of Argument

 Examples: If the attribute "filename" has the value "a brand new filename.txt" and the attribute "hello" does not exist, then the Expression ${filename:replaceNull('abc')} will return "a brand new filename.txt", while ${hello:replaceNull('abc')} will return "abc".

 replaceEmpty

 Description: The replaceEmpty function returns the argument if the Subject is null or if the Subject consists only of white space (new line, carriage return, tab, space). Otherwise, returns the Subject.

 Subject Type: String

 Arguments:

 • Replacement : The value to return if the Subject is null or empty.

 Return Type: String

 Examples: If the attribute "filename" has the value "a brand new filename.txt" and the attribute "hello" has the value " ", then the Expression ${filename:replaceEmpty('abc')} will return "a brand new filename.txt", while ${hello:replaceEmpty('abc')} will return "abc".

 length

 Description: Returns the length of the Subject

 Subject Type: String

 Arguments: No arguments

 Return Type: Number

 Examples: If the attribute "filename" has a value of "a brand new filename.txt" and the attribute "hello" does not exist, then the Expression ${filename:length()} will return 24. ${hello:length()} will return 0.

 evaluateELString

 Description: This function evaluates the Expression Language inside the variable value.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If one of the registry variable named "query" has value "SELECT * FROM TABLE WHERE ID = ${id}" and the value of the "id" field, we are getting from the flowfile attributes (i.e. id=20) then the Expression ${query:evaluateELString()} will return SELECT * FROM TABLE WHERE ID = 20

 repeat

 Description: Returns a string that is the Subject repeated a random number of times between min repeats and max repeats. If max repeats is not supplied, it will return the Subject repeated exactly min repeats times.

 The min repeats and max repeats must be positive numbers, with max repeats greater than or equal to min repeats

 If either min repeats or max repeats is not a number, this function call will result in an error.

 Subject Type: String

 Arguments:

 • min repeats : The minimum number (inclusive) of times to repeat the subject, or the exact number of times to repeat the subject if max repeats is not supplied.

 • max repeats : The maximum number (inclusive) of times to repeat the subject.

 Return Type: String

 Examples:

 If we have an attribute named "str" with the value "abc", then the following Expressions will result in the following values:

 Table 15. Repeat Examples Expression

 | Value

 | 
 ${str:repeat(1)}

 | abc

 | 
 ${str:repeat(2)}

 | abcabc

 | 
 ${str:repeat(1,2)}

 | abc or abcabc (at random)

 | 
 ${str:repeat( ${str:length()} )}

 | abc or abcabc or abcabcabc (at random)

 | 
 replaceByPattern

 Description: Returns a string based on the provided mapping rule in order to replace the subject by another string. If the subject is not covered by the mapping rule, then the subject is returned.

 Subject Type: String

 Argument:

 • mapping rule : The mapping rule is a comma separated list of K:V where K may be a regular expression and V is the string to return in case K matches the subject. Examples: 'abc:xyz,foo:poo' and 'att[0-4]:low_range,att[5-9]:high_range,.*:other'

 Return Type: String

 Examples:

 If we have an attribute named "str" with the value "abc", then the following Expressions will result in the following values:

 Table 16. ReplaceByPattern Examples Expression

 | Value

 | 
 ${str:replaceByPattern('abc:xyz,foo:poo')}

 | xyz

 | 
 ${str:replaceByPattern('foo:poo')}

 | abc

 | 
 ${str:replaceByPattern('a.c:xyz,.*:foo')}

 | xyz

 | 
 Encode/Decode Functions

 Each of the following functions will encode a string according the rules of the given data format.

 escapeJson

 Description: This function prepares the Subject to be inserted into JSON document by escaping the characters in the String using Json String rules. The function correctly escapes quotes and control-chars (tab, backslash, cr, ff, etc.)

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is 'He didn’t say, "Stop!"', then the Expression ${message:escapeJson()} will return 'He didn’t say, \"Stop!\"'

 escapeXml

 Description: This function prepares the Subject to be inserted into XML document by escaping the characters in a String using XML entities. The function correctly escapes quotes, apostrophe, ampersand, <, > and control-chars.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is '"bread" & "butter"', then the Expression ${message:escapeXml()} will return '"bread" & "butter"'

 escapeCsv

 Description: This function prepares the Subject to be inserted into CSV document by escaping the characters in a String using the rules in RFC 4180. The function correctly escapes quotes and surround the string in quotes if needed.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is 'But finally, she left', then the Expression ${message:escapeCsv()} will return '"But finally, she left"'

 escapeHtml3

 Description: This function prepares the Subject to be inserted into HTML document by escaping the characters in a String using the HTML entities. Supports only the HTML 3.0 entities.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is '"bread" & "butter"', then the Expression ${message:escapeHtml3()} will return '"bread" & "butter"'

 escapeHtml4

 Description: This function prepares the Subject to be inserted into HTML document by escaping the characters in a String using the HTML entities. Supports all known HTML 4.0 entities.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is '"bread" & "butter"', then the Expression ${message:escapeHtml4()} will return '"bread" & "butter"'

 unescapeJson

 Description: This function unescapes any Json literals found in the String.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is 'He didn’t say, \"Stop!\"', then the Expression ${message:unescapeJson()} will return 'He didn’t say, "Stop!"'

 unescapeXml

 Description: This function unescapes a string containing XML entity escapes to a string containing the actual Unicode characters corresponding to the escapes. Supports only the five basic XML entities (gt, lt, quot, amp, apos).

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is '"bread" & "butter"', then the Expression ${message:unescapeXml()} will return '"bread" & "butter"'

 unescapeCsv

 Description: This function unescapes a String from a CSV document according to the rules of RFC 4180.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is '"But finally, she left"', then the Expression ${message:unescapeCsv()} will return 'But finally, she left'

 unescapeHtml3

 Description: This function unescapes a string containing HTML 3 entity to a string containing the actual Unicode characters corresponding to the escapes. Supports only HTML 3.0 entities.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is '"bread" & "butter"', then the Expression ${message:unescapeHtml3()} will return '"bread" & "butter"'

 unescapeHtml4

 Description: This function unescapes a string containing HTML 4 entity to a string containing the actual Unicode characters corresponding to the escapes. Supports all known HTML 4.0 entities.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If the "message" attribute is '"bread" & "butter"', then the Expression ${message:unescapeHtml4()} will return '"bread" & "butter"'

 urlEncode

 Description: Returns a URL-friendly version of the Subject. This is useful, for instance, when using an attribute value to indicate the URL of a website.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: We can URL-Encode an attribute named "url" by using the Expression ${url:urlEncode()}. If the value of the "url" attribute is "https://nifi.apache.org/some value with spaces", this Expression will then return "https%3A%2F%2Fnifi.apache.org%2Fsome+value+with+spaces".

 urlDecode

 Description: Converts a URL-friendly version of the Subject into a human-readable form.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If we have a URL-Encoded attribute named "url" with the value "https://nifi.apache.org/some%20value%20with%20spaces" or "https%3A%2F%2Fnifi.apache.org%2Fsome+value+with+spaces", then the Expression ${url:urlDecode()} will return "https://nifi.apache.org/some value with spaces".

 base64Encode

 Description: Returns a Base64 encoded string. This is useful for being able to transfer binary data as ascii.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: We can Base64-Encoded an attribute named "payload" by using the Expression ${payload:base64Encode()} If the attribute payload had a value of "admin:admin" then the Expression ${payload:base64Encode()} will return "YWRtaW46YWRtaW4=".

 base64Decode

 Description: Reverses the Base64 encoding on given string.

 Subject Type: String

 Arguments: No arguments

 Return Type: String

 Examples: If we have a Base64-Encoded attribute named "payload" with the value "YWRtaW46YWRtaW4=", then the Expression ${payload:base64Decode()} will return "admin:admin".

 UUID3

 Description: Returns a type 3 (MD5 hashed) namespace name-based UUID. The argument must be a valid UUID.

 Subject Type: String

 Arguments:

 • namespace : The namespace UUID identifier

 Return Type: String

 Examples: If we have an attribute named "attr" with a value of "string value", then the Expression ${attr:UUID3('b9e81de3-7047-4b5e-a822-8fff5b49f808')} will return "bf0ea246-a177-3300-bd7e-d4c9e973dc6f".

 An empty argument or an argument value with an invalid UUID results in an exception bulletin.

 See Also: UUID()

 UUID5

 Description: Returns a type 5 (SHA-1 hashed) namespace name-based UUID. The argument must be a valid UUID.

 Subject Type: String

 Arguments:

 • namespace : The namespace UUID identifier

 Return Type: String

 Examples: If we have an attribute named "attr" with a value of "string value", then the Expression ${attr:UUID5('245b55a8-397d-4480-a41e-16603c8cf9ad')} will return "4d111477-5100-5f2d-ae79-b38bbe15aa78".

 An empty argument or an argument value with an invalid UUID results in an exception bulletin.

 See Also: UUID()

 hash

 Description: Returns a hex encoded string using the hash algorithm provided. This can be used to generate unique keys.

 Subject Type: String

 Arguments:

 • algorithm : An algorithm to hash value. Supports one of [SHA-384, SHA-224, SHA-256, MD2, SHA, SHA-512, MD5]. Warning: MD2, MD5, and SHA (SHA-1) should not be considered cryptographically secure (https://csrc.nist.gov/projects/hash-functions/nist-policy-on-hash-functions).

 Return Type: String

 Examples: We can hash an attribute named "payload" by using the Expression ${payload:hash('SHA-256')} If the attribute payload had a value of "string value" then the Expression ${payload:hash('SHA-256')} will return "9b6a1a9167a5caf3f5948413faa89e0ec0de89e12bef55327442e60dcc0e8c9b".

 Searching

 Each of the following functions is used to search its subject for some value.

 startsWith

 Description: Returns true if the Subject starts with the String provided as the argument, false otherwise.

 Subject Type: String

 Arguments:

 • value : The value to search for

 Return Type: Boolean

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the Expression ${filename:startsWith('a brand')} will return true. ${filename:startsWith('A BRAND')} will return false. ${filename:toUpper():startsWith('A BRAND')} returns true.

 endsWith

 Description: Returns true if the Subject ends with the String provided as the argument, false otherwise.

 Subject Type: String

 Arguments:

 • value : The value to search for

 Return Type: Boolean

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the Expression ${filename:endsWith('txt')} will return true. ${filename:endsWith('TXT')} will return false. ${filename:toUpper():endsWith('TXT')} returns true.

 contains

 Description: Returns true if the Subject contains the value of the argument anywhere in the value.

 Subject Type: String

 Arguments:

 • value : The value to search for

 Return Type: Boolean

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the Expression ${filename:contains('new')} will return true. ${filename:contains('NEW')} will return false. ${filename:toUpper():contains('NEW')} returns true.

 in

 Description: Returns true if the Subject is matching one of the provided arguments.

 Subject Type: String

 Arguments:

 • value1 : First possible matching value

 • valueN : Nth possible matching value

 Return Type: Boolean

 Examples: If the "myEnum" attribute has the value "JOHN", then the Expression ${myEnum:in("PAUL", "JOHN", "MIKE")} will return true. ${myEnum:in("RED", "GREEN", "BLUE")} will return false.

 find

 Description: Returns true if the Subject contains any sequence of characters that matches the Regular Expression provided by the argument.

 Subject Type: String

 Arguments:

 • Regex : The Regular Expression (in the Java Pattern syntax) to match against the Subject

 Return Type: Boolean

 Examples:

 If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will provide the following results:

 Table 17. find Examples Expression

 | Value

 | 
 ${filename:find('a [Bb]rand [Nn]ew')}

 | true

 | 
 ${filename:find('Brand.*')}

 | false

 | 
 ${filename:find('brand')}

 | true

 | 
 matches

 Description: Returns true if the Subject exactly matches the Regular Expression provided by the argument.

 Subject Type: String

 Arguments:

 • Regex : The Regular Expression (in the Java Pattern syntax) to match against the Subject

 Return Type: Boolean

 Examples:

 If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will provide the following results:

 Table 18. matches Examples Expression

 | Value

 | 
 ${filename:matches('a.*txt')}

 | true

 | 
 ${filename:matches('brand')}

 | false

 | 
 ${filename:matches('.brand.')}

 | true

 | 
 indexOf

 Description: Returns the index of the first character in the Subject that matches the String value provided as an argument. If the argument is found multiple times within the Subject, the value returned is the starting index of the first occurrence. If the argument cannot be found in the Subject, returns -1. The index is zero-based. This means that if the search string is found at the beginning of the Subject, the value returned will be 0, not 1.

 Subject Type: String

 Arguments:

 • value : The value to search for in the Subject

 Return Type: Number

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will provide the following results:

 Table 19. indexOf Examples Expression

 | Value

 | 
 ${filename:indexOf('a.*txt')}

 | -1

 | 
 ${filename:indexOf('.')}

 | 20

 | 
 ${filename:indexOf('a')}

 | 0

 | 
 ${filename:indexOf(' ')}

 | 1

 | 
 lastIndexOf

 Description: Returns the index of the first character in the Subject that matches the String value provided as an argument. If the argument is found multiple times within the Subject, the value returned is the starting index of the last occurrence. If the argument cannot be found in the Subject, returns -1. The index is zero-based. This means that if the search string is found at the beginning of the Subject, the value returned will be 0, not 1.

 Subject Type: String

 Arguments:

 • value : The value to search for in the Subject

 Return Type: Number

 Examples: If the "filename" attribute has the value "a brand new filename.txt", then the following Expressions will provide the following results:

 Table 20. lastIndexOf Examples Expression

 | Value

 | 
 ${filename:lastIndexOf('a.*txt')}

 | -1

 | 
 ${filename:lastIndexOf('.')}

 | 20

 | 
 ${filename:lastIndexOf('a')}

 | 17

 | 
 ${filename:lastIndexOf(' ')}

 | 11

 | 
 jsonPath

 Description: The jsonPath function generates a string by evaluating the Subject as JSON and applying a JSON path expression. An empty string is generated if the Subject does not contain valid JSON, the jsonPath is invalid, or the path does not exist in the Subject. If the evaluation results in a scalar value, the string representation of scalar value is generated. Otherwise a string representation of the JSON result is generated. A JSON array of length 1 is special cased when [0] is a scalar, the string representation of [0] is generated.

 Subject Type: String

 Arguments: jsonPath : the JSON path expression used to evaluate the Subject.

 Return Type: String

 Examples: If the "myJson" attribute is

 {
 "firstName": "John",
 "lastName": "Smith",
 "isAlive": true,
 "age": 25,
 "address": {
 "streetAddress": "21 2nd Street",
 "city": "New York",
 "state": "NY",
 "postalCode": "10021-3100"
 },
 "phoneNumbers": [
 {
 "type": "home",
 "number": "212 555-1234"
 },
 {
 "type": "office",
 "number": "646 555-4567"
 }
 ],
 "children": [],
 "spouse": null
} Table 21. jsonPath Examples Expression

 | Value

 | 
 ${myJson:jsonPath('$.firstName')}

 | John

 | 
 ${myJson:jsonPath('$.address.postalCode')}

 | 10021-3100

 | 
 ${myJson:jsonPath('$.phoneNumbers[?(@.type=="home")].number')}

 | 212 555-1234

 | 
 ${myJson:jsonPath('$.phoneNumbers')}

 | [{"type":"home","number":"212 555-1234"},{"type":"office","number":"646 555-4567"}]

 | 
 ${myJson:jsonPath('$.missing-path')}

 | empty

 | 
 ${myJson:jsonPath('$.bad-json-path..')}

 | exception bulletin

 | 
 An empty subject value or a subject value with an invalid JSON document results in an exception bulletin.

 jsonPathDelete

 Description: The jsonPathDelete function deletes the specified JsonPath from a Subject JSON and returns string form of the updated JSON.

 Subject Type: String

 Arguments: jsonPath : the JSON path expression to delete from the Subject.

 Return Type: String

 Examples: If the "myJson" attribute is

 {
 "firstName": "John",
 "lastName": "Smith",
 "isAlive": true,
 "age": 25,
 "address": {
 "streetAddress": "21 2nd Street",
 "city": "New York",
 "state": "NY",
 "postalCode": "10021-3100"
 },
 "phoneNumbers": [
 {
 "type": "home",
 "number": "212 555-1234"
 },
 {
 "type": "office",
 "number": "646 555-4567"
 }
 ],
 "children": [],
 "spouse": null
} Table 22. jsonPathDelete Examples Expression

 | Value

 | 
 ${myJson:jsonPathDelete('$.firstName')}

 | {"lastName":"Smith","age":25,"address":{"streetAddress":"21 2nd Street","city":"New York","state":"NY","postalCode":"10021-3100"},"phoneNumbers":[{"type":"home","number":"212 555-1234"},{"type":"office","number":"646 555-4567"}]}

 | 
 ${myJson:jsonPathDelete('$.missing-path')}

 | Returns original JSON document

 | 
 An empty subject value or a subject value with an invalid JSON document results in an exception bulletin.

 jsonPathAdd

 Description: The jsonPathAdd function adds a scalar value to an array at the specified JsonPath on a Subject JSON and returns string form of the updated JSON. If the expression target element is a non-array, an empty string is returned and an exception is logged indicating the error. If the expression target element path is not in the JSON, the operation returns the original JSON without any modifications.

 Subject Type: String

 Arguments:

 • jsonPath : the JSON path expression to set value on the Subject.

 • value : the value expression to be added to the array at the specified path on Subject.

 Return Type: String

 Examples: If the "myJson" attribute is

 {
 "firstName": "John",
 "lastName": "Smith",
 "age": 25,
 "voter" : true,
 "height" : 6.1,
 "address" : {
 "streetAddress": "21 2nd Street",
 "city": "New York",
 "state": "NY",
 "postalCode": "10021-3100"
 },
 "phoneNumbers": [
 {
 "type": "home",
 "number": "212 555-1234"
 },
 {
 "type": "office",
 "number": "646 555-4567"
 }
 ],
 "nicknames" : []
 } Table 23. jsonPathAdd Examples Expression

 | Value

 | 
 ${myJson:jsonPathAdd('$.nicknames', 'Jimmy')}

 | {"firstName":"James", lastName":"Smith", "age":25, "voter":true, "height":6.1, "address":{"streetAddress":"21 2nd Street", "city":"New York", "state":"NY", "postalCode":"10021-3100"}, "phoneNumbers":[{"type":"home", "number":"212 555-1234"}, {"type":"office", "number":"646 555-4567"}],"nicknames":["Jimmy"]}

 | 
 ${myJson:jsonPathAdd('$.missingpath', 'Jimmy')}

 | Returns original JSON document with no modifications

 | 
 ${myJson:jsonPathAdd('$.firstName', 'Jimmy')}

 | empty

 | 
 jsonPathSet

 Description: The jsonPathSet function sets the value at the specified JsonPath on a Subject JSON and returns string form of the updated JSON.

 Subject Type: String

 Arguments:

 • jsonPath : the JSON path expression to set value on the Subject.

 • value : the value expression to be set on the specified path on Subject.

 Return Type: String

 Examples: If the "myJson" attribute is

 {
 "firstName": "John",
 "lastName": "Smith",
 "age": 25,
 "voter" : true,
 "height" : 6.1,
 "address" : {
 "streetAddress": "21 2nd Street",
 "city": "New York",
 "state": "NY",
 "postalCode": "10021-3100"
 },
 "phoneNumbers": [
 {
 "type": "home",
 "number": "212 555-1234"
 },
 {
 "type": "office",
 "number": "646 555-4567"
 }
 ],
 "nicknames" : []
 } Table 24. jsonPathSet Examples Expression

 | Value

 | 
 ${myJson:jsonPathSet('$.firstName', 'James')}

 | {"firstName":"James", lastName":"Smith", "age":25, "voter":true, "height":6.1, "address":{"streetAddress":"21 2nd Street", "city":"New York", "state":"NY", "postalCode":"10021-3100"}, "phoneNumbers":[{"type":"home", "number":"212 555-1234"}, {"type":"office", "number":"646 555-4567"}]}

 | 
 ${myJson:jsonPathSet('$.missingpath', 'James')}

 | Returns original JSON document

 | 
 An empty subject value or a subject value with an invalid JSON document results in an exception bulletin.

 jsonPathPut

 Description: The jsonPathPut function puts the key and scalar value at the specified JsonPath on a Subject JSON and returns string form of the updated JSON.

 Subject Type: String

 Arguments:

 • jsonPath : the JSON path expression to set value on the Subject.

 • value : the value expression to be set on the specified path on Subject.

 • key : the key expression with the associated value the specified path on Subject.

 Return Type: String

 Examples: If the "myJson" attribute is

 {
 "firstName": "John",
 "lastName": "Smith",
 "age": 25,
 "voter" : true,
 "height" : 6.1,
 "address" : {
 "streetAddress": "21 2nd Street",
 "city": "New York",
 "state": "NY",
 "postalCode": "10021-3100"
 },
 "phoneNumbers": [
 {
 "type": "home",
 "number": "212 555-1234"
 },
 {
 "type": "office",
 "number": "646 555-4567"
 }
 ],
 "nicknames" : []
 } Table 25. jsonPathPut Examples Expression

 | Value

 | 
 ${myJson:jsonPathPut('$','middlename','Turon')}

 | {"firstName":"James", lastName":"Smith", "middlename": "Turon", "age":25, "voter":true, "height":6.1, "address":{"streetAddress":"21 2nd Street", "city":"New York", "state":"NY", "postalCode":"10021-3100"}, "phoneNumbers":[{"type":"home", "number":"212 555-1234"}, {"type":"office", "number":"646 555-4567"}]}

 | 
 An empty subject value or a subject value with an invalid JSON document results in an exception bulletin.

 Mathematical Operations and Numeric Manipulation

 For those functions that support Decimal and Number (whole number) types, the return value type depends on the input types. If either the subject or argument are a Decimal then the result will be a Decimal. If both values are Numbers then the result will be a Number. This includes Divide. This is to preserve backwards compatibility and to not force rounding errors.

 plus

 Description: Adds a numeric value to the Subject. If either the argument or the Subject cannot be coerced into a Number, returns null. Does not provide handling for overflow.

 Subject Type: Number or Decimal

 Arguments:

 • Operand : The value to add to the Subject

 Return Type: Number or Decimal (depending on input types)

 Examples: If the "fileSize" attribute has a value of 100, then the Expression ${fileSize:plus(1000)} will return the value 1100.

 minus

 Description: Subtracts a numeric value from the Subject. Does not provide handling for overflow.

 Subject Type: Number or Decimal

 Arguments:

 • Operand : The value to subtract from the Subject

 Return Type: Number or Decimal (depending on input types)

 Examples: If the "fileSize" attribute has a value of 100, then the Expression ${fileSize:minus(100)} will return the value 0.

 multiply

 Description: Multiplies a numeric value by the Subject and returns the product. Does not provide handling for overflow.

 Subject Type: Number or Decimal

 Arguments:

 • Operand : The value to multiple the Subject by

 Return Type: Number or Decimal (depending on input types)

 Examples: If the "fileSize" attribute has a value of 100, then the Expression ${fileSize:multiply(1024)} will return the value 102400.

 divide

 Description: Divides the Subject by a numeric value and returns the result.

 Subject Type: Number or Decimal

 Arguments:

 • Operand : The value to divide the Subject by

 Return Type: Number or Decimal (depending on input types)

 Examples: If the "fileSize" attribute has a value of 100, then the Expression ${fileSize:divide(12)} will return the value 8.

 mod

 Description: Performs a modular division of the Subject by the argument. That is, this function will divide the Subject by the value of the argument and return not the quotient but rather the remainder.

 Subject Type: Number or Decimal

 Arguments:

 • Operand : The value to divide the Subject by

 Return Type: Number or Decimal (depending on input types)

 Examples: If the "fileSize" attribute has a value of 100, then the Expression ${fileSize:mod(12)} will return the value 4.

 toRadix

 Description: Converts the Subject from a Base 10 number to a different Radix (or number base). An optional second argument can be used to indicate the minimum number of characters to be used. If the converted value has fewer than this number of characters, the number will be padded with leading zeroes. If a decimal is passed as the subject, it will first be converted to a whole number and then processed.

 Subject Type: Number

 Arguments:

 • Desired Base : A Number between 2 and 36 (inclusive)

 • Padding : Optional argument that specifies the minimum number of characters in the converted output

 Return Type: String

 Examples: If the "fileSize" attributes has a value of 1024, then the following Expressions will yield the following results:

 Table 26. toRadix Examples Expression

 | Value

 | 
 ${fileSize:toRadix(10)}

 | 1024

 | 
 ${fileSize:toRadix(10, 1)}

 | 1024

 | 
 ${fileSize:toRadix(10, 8)}

 | 00001024

 | 
 ${fileSize:toRadix(16)}

 | 400

 | 
 ${fileSize:toRadix(16, 8)}

 | 00000400

 | 
 ${fileSize:toRadix(2)}

 | 10000000000

 | 
 ${fileSize:toRadix(2, 16)}

 | 0000010000000000

 | 
 fromRadix

 Description: Converts the Subject from a specified Radix (or number base) to a base ten whole number. The subject will converted as is, without interpretation, and all characters must be valid for the base being converted from. For example converting "0xFF" from hex will not work due to "x" being a invalid hex character. If a decimal is passed as the subject, it will first be converted to a whole number and then processed.

 Subject Type: String

 Arguments:

 • Subject Base : A Number between 2 and 36 (inclusive)

 Return Type: Number

 Examples: If the "fileSize" attributes has a value of 1234A, then the following Expressions will yield the following results:

 Table 27. toRadix Examples Expression

 | Value

 | 
 ${fileSize:fromRadix(11)}

 | 17720

 | 
 ${fileSize:fromRadix(16)}

 | 74570

 | 
 ${fileSize:fromRadix(20)}

 | 177290

 | 
 random

 Description: Returns a random whole number ( 0 to 2^63 - 1) using an insecure random number generator.

 Subject Type: No subject

 Arguments: No arguments

 Return Type: Number

 Examples: ${random():mod(10):plus(1)} returns random number between 1 and 10 inclusive.

 math

 Description: ADVANCED FEATURE. This expression is designed to be used by advanced users only. It utilizes Java Reflection to run arbitrary java.lang.Math static methods. The exact API will depend on the version of Java you are running. The Java API can be found here: https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Math.html 
 In order to run the correct method, the parameter types must be correct. The Expression Language "Number" (whole number) type is interpreted as a Java "long". The "Decimal" type is interpreted as a Java "double". Running the desired method may require calling "toNumber()" or "toDecimal()" in order to "cast" the value to the desired type. This also is important to remember when cascading "math()" calls since the return type depends on the method that was run.

 Subject Type: Subjectless, Number or Decimal (depending on the desired method to run)

 Arguments:

 • Method : The name of the Java Math method to run

 • Optional Argument : Optional argument that acts as the second parameter to the method.

 Return Type: Number or Decimal (depending on method run)

 Examples:

 • ${math("random")} runs Math.random().

 • ${literal(2):toDecimal:math("pow", 2.5)} runs Math.pow(2D,2.5D).

 • ${literal(64):toDecimal():math("cbrt"):toNumber():math("max", 5)} runs Math.maxDouble.valueOf(Math.cbrt(64D).longValue(), 5L). Note that the toDecimal() is needed because "cbrt" takes a "double" as input and the "64" will get interpreted as a long. The "toDecimal()" call is necessary to correctly call the method. that the "toNumber()" call is necessary because "cbrt" returns a double and the "max" method is must have parameters of the same type and "5" is interpreted as a long.

 • ${literal(5.4):math("scalb", 2)} runs Math.scalb(5.4, 2). This example is important because NiFi EL treats all whole numbers as "longs" and there is no concept of an "int". "scalb" takes a second parameter of an "int" and it is not overloaded to accept longs so it could not be run without special type handling. In the instance where the Java method cannot be found using parameters of type "double" and "long" the "math()" EL function will attempt to find a Java method with the same name but parameters of "double" and "int".

 • ${first:toDecimal():math("pow", ${second:toDecimal()})} where attributes evaluate to "first" = 2.5 and "second" = 2. This example runs Math.pow(2.5D, 2D). The explicit calls to toDecimal() are important because of the dynamic nature of EL. When creating the flow, the user is unaware if the expression language values will be able to be interpreted as a whole number or not. In this example without the explicit calls "toDecimal" the "math" function would attempt to run a Java method "pow" with types "double" and "long" (which doesn’t exist).

 Date Manipulation

 format

 Description: Formats a number as a date/time according to the format specified by the argument. The argument must be a String that is a valid Java DateTimeFormatter format. The Subject is expected to be a Number that represents the number of milliseconds since Midnight GMT on January 1, 1970. The number will be evaluated using the local time zone unless specified in the second optional argument.

 Subject Type: Number

 Arguments:

 • format : The format to use in the Java DateTimeFormatter syntax

 • time zone : Optional argument that specifies the time zone to use (in the Java TimeZone syntax)

 Return Type: String

 Examples: If the attribute "time" has the value "1420058163264", then the following Expressions will yield the following results:

 Table 28. format Examples Expression

 | Value

 | 
 ${time:format("yyyy/MM/dd HH:mm:ss.SSS'Z'", "GMT")}

 | 2014/12/31 20:36:03.264Z

 | 
 ${time:format("yyyy/MM/dd HH:mm:ss.SSS'Z'", "America/Los_Angeles")}

 | 2014/12/31 12:36:03.264Z

 | 
 ${time:format("yyyy/MM/dd HH:mm:ss.SSS'Z'", "Asia/Tokyo")}

 | 2015/01/01 05:36:03.264Z

 | 
 ${time:format("yyyy/MM/dd", "GMT")}

 | 2014/12/31

 | 
 ${time:format("HH:mm:ss.SSS'Z'", "GMT")}

 | 20:36:03.264Z

 | 
 ${time:format("yyyy", "GMT")}

 | 2014

 | 
 formatInstant

 Description: [.description]#Formats an Instant, number or string according to the format specified by the argument.

 The first argument must be a String that is a valid Java DateTimeFormatter format. The second argument must be a String that is a valid time zone. The Subject is expected to be an Instant, String or Number that represents the number of milliseconds since Midnight GMT on January 1, 1970 or a String with one of the following

 DateTimeFormatter syntaxes:#

 • ISO_OFFSET such as '2011-12-03T10:15:30+01:00'

 • ISO_INSTANT such as '2011-12-03T10:15:30Z'

 • RFC_1123 such as 'Thu, 01 Dec 1994 16:00:00 GMT'

 Subject Type: Instant or Number or String

 Arguments:

 • format : The format to use in the Java DateTimeFormatter syntax

 • time zone : Optional argument that specifies the time zone to use (in the Java TimeZone syntax)

 Return Type: String

 Examples: If the attribute "time" has the value "1647884009479", timeIsoOffset has the value "2022-12-03T10:15:30+01:00", timeIsoInstant has the value "2022-12-03T10:15:30Z" and "timeRFC1123" has the value "Thu, 01 Dec 2022 16:00:00 GMT", then the following Expressions will yield the following results:

 Table 29. format Examples Expression

 | Value

 | 
 ${time:formatInstant("yyyy/MM/dd HH:mm:ss.SSS'Z'", "GMT")}

 | 2022/03/21 17:33:29.479Z

 | 
 ${timeIsoOffset:formatInstant("yyyy/MM/dd HH:mm:ss.SSS'Z'", "Asia/Tokyo")}

 | 2022/12/03 18:15:30.000Z

 | 
 ${timeIsoInstant:formatInstant("yyyy/MM/dd", "Asia/Tokyo")}

 | 2022/12/03 19:15:30.000Z

 | 
 ${timeRFC1123:formatInstant("yyyy/MM/dd HH:mm:ss.SSS'Z'", "GMT")}

 | 2022/12/01 16:00:00.000Z

 | 
 toDate

 Description: Converts a String into a Date data type, based on the format specified by the argument. The argument must be a String that is a valid Java DateTimeFormatter syntax. The Subject is expected to be a String that is formatted according the argument. The date will be evaluated using the local time zone unless specified in the second optional argument.

 Subject Type: String

 Arguments:

 • format : The current format to use when parsing the Subject, in the Java DateTimeFormatter syntax.

 • time zone : Optional argument that specifies the time zone to use when parsing the Subject, in the Java TimeZone syntax.

 Return Type: Date

 Examples: If the attribute "year" has the value "2014" and the attribute "time" has the value "2014/12/31 15:36:03.264Z", then the Expression ${year:toDate('yyyy', 'GMT')} will return a Date data type with a value representing Midnight GMT on January 1, 2014. The Expression ${time:toDate("yyyy/MM/dd HH:mm:ss.SSS’Z'", "GMT")} will result in a Date data type for 15:36:03.264 GMT on December 31, 2014.

 Often, this function is used in conjunction with the format function to change the format of a date/time. For example, if the attribute "date" has the value "12-24-2014" and we want to change the format to "2014/12/24", we can do so by chaining together the two functions: ${date:toDate('MM-dd-yyyy'):format('yyyy/MM/dd')}.

 toInstant

 Description: Converts a String or Number into an Instant data type, based on the format specified by the argument. In case of String format nanosecond precision date parsing is supported. The argument must be a String that is a valid Java DateTimeFormatter syntax. The Subject is expected to be a String that is formatted according the argument or a number which represents the datetime in milliseconds. The datetime will be evaluated using the time zone specified in the second argument.

 Subject Type: String or Number

 Arguments:

 • format : The current format to use when parsing the Subject, in the Java DateTimeFormatter syntax.

 • time zone : Required argument that specifies the time zone to use when parsing the Subject, in the Java TimeZone syntax.

 Return Type: Instant

 Examples: If the attribute "time" has the value "2014/12/31 15:36:03.264Z" then the expression ${time:toInstant("yyyy/MM/dd HH:mm:ss.SSS’Z'", "GMT")} will result in an Instant data type for 15:36:03.264 GMT on December 31, 2014.

 Often, this function is used in conjunction with the formatInstant function to change the format of a date/time. For example, if the attribute "dateTime" has the value "12-24-2014 12:06:59" and we want to change the format to "2014/12/24", we can do so by chaining together the two functions: ${dateTime:toInstant('MM-dd-yyyy HH:mm:ss', 'GMT'):formatInstant('yyyy/MM/dd', 'GMT')}.

 toMicros

 Description: Converts an Instant Subject into a Number with microsecond precision

 Subject Type: Instant

 Arguments: No arguments

 Return Type: Number

 Examples: If the "dateTime" attribute has the value of "2022/03/18 10:22:27.678234567", then the Expression ${dateTime:toInstant('yyyy/MM/dd HH:mm:ss.SSSSSSSSS', 'America/New_York'):toMicros()} converts the Instant value of the attribute to 1647613347678234 microseconds since epoch.

 toNanos

 Description: Converts an Instant Subject into a Number with nanosecond precision

 Subject Type: Instant

 Arguments: No arguments

 Return Type: Number

 Examples: If the "dateTime" attribute has the value of "2022/03/18 10:22:27.678234567", then the Expression ${dateTime:toInstant('yyyy/MM/dd HH:mm:ss.SSSSSSSSS', 'America/New_York'):toNanos()} converts the Instant value of the attribute to 1647613347678234567 nanoseconds since epoch.

 now

 Description: Returns the current date and time as a Date data type object.

 Subject Type: No Subject

 Arguments: No arguments

 Return Type: Date

 Examples: We can get the current date and time as a Date data type by using the now function: ${now()}. As an example, on Wednesday December 31st 2014 at 36 minutes after 3pm and 36.123 seconds EST ${now()} would be evaluated to be a Date type representing that time. Since whole Expression Language expressions can only return Strings it would formatted as Wed Dec 31 15:36:03 EST 2014 when the expression completes.

 Utilizing the toNumber method, now can provide the current date and time as the number of milliseconds since Midnight GMT on January 1, 1970. For instance, if instead of executing ${now()} in the previous example ${now():toNumber()} was run then it would output 1453843201123. This method provides millisecond-level precision and provides the ability to manipulate the value.

 Table 30. now Examples Expression

 | Value

 | 
 ${now()}

 | A Date type representing the current date and time to the nearest millisecond

 | 
 ${now():toNumber()}

 | The number of milliseconds since midnight GMT Jan 1, 1970 (1453843201123, for example)

 | 
 ${now():toNumber():minus(86400000)

 | A number presenting the time 24 hours ago

 | 
 ${now():format('yyyy')}

 | The current year

 | 
 ${now():toNumber():minus(86400000):format('E')}

 | The day of the week that was yesterday, as a 3-letter abbreviation (For example, Wed)

 | 
 Type Coercion

 toString

 Description: Coerces the Subject into a String

 Subject Type: Any type

 Arguments: No arguments

 Return Type: String

 Examples: The Expression ${fileSize:toNumber():toString()} converts the value of "fileSize" attribute to a number and back to a String.

 toNumber

 Description: Coerces the Subject into a Number

 Subject Type: String, Decimal, or Date

 Arguments: No arguments

 Return Type: Number

 Examples: The Expression ${fileSize:toNumber()} converts the attribute value of "fileSize" to a number.

 toDecimal

 Description: Coerces the Subject into a Decimal

 Subject Type: String, Whole Number or Date

 Arguments: No arguments

 Return Type: Decimal

 Examples: The Expression ${fileSize:toDecimal()} converts the attribute value of "fileSize" to a decimal.

 Subjectless Functions

 While the majority of functions in the Expression Language are called by using the syntax ${attributeName:function()}, there exist a few functions that are not expected to have subjects. In this case, the attribute name is not present. For example, the IP address of the machine can be obtained by using the Expression ${ip()}. All of the functions in this section are to be called without a subject. Attempting to call a subjectless function and provide it a subject will result in an error when validating the function.

 ip

 Description: Returns the IP address of the machine.

 Subject Type: No subject

 Arguments: No arguments

 Return Type: String

 Examples: The IP address of the machine can be obtained by using the Expression ${ip()}.

 hostname

 Description: Returns the Hostname of the machine. An optional argument of type Boolean can be provided to specify whether or not the Fully Qualified Domain Name should be used. If false, or not specified, the hostname will not be fully qualified. If the argument is true but the fully qualified hostname cannot be resolved, the simple hostname will be returned.

 Subject Type: No subject

 Arguments:

 • Fully Qualified : Optional parameter that specifies whether or not the hostname should be fully qualified. If not specified, defaults to false.

 Return Type: String

 Examples: The fully qualified hostname of the machine can be obtained by using the Expression ${hostname(true)}, while the simple hostname can be obtained by using either ${hostname(false)} or simply ${hostname()}.

 UUID

 Description: Returns a randomly generated type 4 UUID.

 Subject Type: No Subject

 Arguments: No arguments

 Return Type: String

 Examples: ${UUID()} returns a value similar to "de305d54-75b4-431b-adb2-eb6b9e546013"

 See Also: UUID3(), UUID5()

 nextInt

 Description: Returns a one-up value (starting at 0) and increasing over the lifetime of the running instance of NiFi. This value is not persisted across restarts and is not guaranteed to be unique across a cluster. This value is considered "one-up" in that if called multiple times across the NiFi instance, the values will be sequential. However, this counter is shared across all NiFi components, so calling this function multiple times from one Processor will not guarantee sequential values within the context of a particular Processor.

 Subject Type: No Subject

 Arguments: No arguments

 Return Type: Number

 Examples: If the previous value returned by nextInt was 5, the Expression ${nextInt():divide(2)} obtains the next available integer (6) and divides the result by 2, returning a value of 3.

 literal

 Description: Returns its argument as a literal String value. This is useful in order to treat a string or a number at the beginning of an Expression as an actual value, rather than treating it as an attribute name. Additionally, it can be used when the argument is an embedded Expression that we would then like to evaluate additional functions against.

 Subject Type: No Subject

 Arguments:

 • value : The value to be treated as a literal string, number, or boolean value.

 Return Type: String

 Examples: ${literal(2):gt(1)} returns true

 ${literal( ${allMatchingAttributes('a.*'):count()} ):gt(3)} returns true if there are more than 3 attributes whose names begin with the letter a.

 getStateValue

 Description: Access a processor’s state values by passing in the String key and getting the value back as a String. This is a special Expression Language function that only works with processors that explicitly allow EL to query state. Currently only UpdateAttribute does.

 Subject Type: No Subject

 Arguments:

 • Key : The key to use when accessing the state map.

 Return Type: String

 Examples: UpdateAttribute processor has stored the key "count" with value "20" in state. '${getStateValue("count")}` returns 20.

 thread

 Description: Returns the name of the thread used by the processor when evaluating the Expression. This can be useful when using a processor with multiple concurrent tasks and where some data uniqueness is required.

 Subject Type: No Subject

 Arguments: No arguments

 Return Type: String

 Examples: ${thread()} could return something like Timer-Driven Process Thread-4.

 getUri

 Description: Returns a URI compliant with RFC 2396. This includes encoding non-US-ASCII characters and quoting illegal characters with octets. This expression utilizes the java.net.URI class to build a URI. As described in the API, a hierarchical URI consists of seven components represented with the following types:

 Component

 | Type

 | 
 scheme

 | String

 | 
 user-info

 | String

 | 
 host

 | String

 | 
 port

 | int

 | 
 path

 | String

 | 
 query

 | String

 | 
 fragment

 | String

 | 
 See the API for more details on character categories, encoding and quoting.

 Subject Type: No Subject

 Arguments: This expression takes seven arguments.

 • scheme, userinfo, host, port, path, query, fragment

 NOTE: Any component of the new URI may be left undefined by passing null for the corresponding parameter or, in the case of the port parameter, by passing -1.

 Return Type: String

 Examples The following examples detail how this expression can be invoked:

 Expression

 | Value

 | 
 ${getUri('https', 'admin:admin', 'nifi.apache.org', '1234', '/path/data ', 'key=value &key2=value2', 'frag1')}

 | https://admin:admin@nifi.apache.org:1234/path/data%20?key=value%20&key2=value2#frag1

 | 
 ${getUri('https', null, 'nifi.apache.org', 8443, '/docs.html', null, null)}

 | https://nifi.apache.org:8443/docs.html

 | 
 ${getUri('http', null, 'nifi.apache.org', -1, '/docs.html', null, null)}

 | http://nifi.apache.org/docs.html

 | 
 Evaluating Multiple Attributes

 When it becomes necessary to evaluate the same conditions against multiple attributes, this can be accomplished by means of the and and or functions. However, this quickly becomes tedious, error-prone, and difficult to maintain. For this reason, NiFi provides several functions for evaluating the same conditions against groups of attributes at the same time.

 anyAttribute

 Description: Checks to see if any of the given attributes, match the given condition. This function has no subject and takes one or more arguments that are the names of attributes to which the remainder of the Expression is to be applied. If any of the attributes specified, when evaluated against the rest of the Expression, returns a value of true, then this function will return true. Otherwise, this function will return false.

 Subject Type: No Subject

 Arguments:

 • Attribute Names : One or more attribute names to evaluate

 Return Type: Boolean

 Examples: Given that the "abc" attribute contains the value "hello world", "xyz" contains "good bye world", and "filename" contains "file.txt" consider the following examples:

 Table 31. anyAttribute Examples Expression

 | Value

 | 
 ${anyAttribute("abc", "xyz"):contains("bye")}

 | true

 | 
 ${anyAttribute("filename","xyz"):toUpper():contains("e")}

 | false

 | 
 allAttributes

 Description: Checks to see if all of the given attributes match the given condition. This function has no subject and takes one or more arguments that are the names of attributes to which the remainder of the Expression is to be applied. If all of the attributes specified, when evaluated against the rest of the Expression, returns a value of true, then this function will return true. Otherwise, this function will return false.

 Subject Type: No Subject

 Arguments:

 • Attribute Names : One or more attribute names to evaluate

 Return Type: Boolean

 Examples: Given that the "abc" attribute contains the value "hello world", "xyz" contains "good bye world", and "filename" contains "file.txt" consider the following examples:

 Table 32. allAttributes Example Expression

 | Value

 | 
 ${allAttributes("abc", "xyz"):contains("world")}

 | true

 | 
 ${allAttributes("abc", "filename","xyz"):toUpper():contains("e")}

 | false

 | 
 anyMatchingAttribute

 Description: Checks to see if any of the given attributes, match the given condition. This function has no subject and takes one or more arguments that are Regular Expressions to match against attribute names. Any attribute whose name matches one of the supplied Regular Expressions will be evaluated against the rest of the Expression. If any of the attributes specified, when evaluated against the rest of the Expression, returns a value of true, then this function will return true. Otherwise, this function will return false.

 Subject Type: No Subject

 Arguments:

 • Regex : One or more Regular Expressions (in the Java Pattern syntax) to evaluate against attribute names

 Return Type: Boolean

 Examples: Given that the "abc" attribute contains the value "hello world", "xyz" contains "good bye world", and "filename" contains "file.txt" consider the following examples:

 Table 33. anyMatchingAttribute Example Expression

 | Value

 | 
 ${anyMatchingAttribute("[ax].*"):contains('bye')}

 | true

 | 
 ${anyMatchingAttribute(".*"):isNull()}

 | false

 | 
 allMatchingAttributes

 Description: Checks to see if any of the given attributes, match the given condition. This function has no subject and takes one or more arguments that are Regular Expressions to match against attribute names. Any attribute whose name matches one of the supplied Regular Expressions will be evaluated against the rest of the Expression. If all of the attributes specified, when evaluated against the rest of the Expression, return a value of true, then this function will return true. Otherwise, this function will return false.

 Subject Type: No Subject

 • Regex : One or more Regular Expressions (in the Java Pattern syntax) to evaluate against attribute names

 Return Type: Boolean

 Examples: Given that the "abc" attribute contains the value "hello world", "xyz" contains "good bye world", and "filename" contains "file.txt" consider the following examples:

 Table 34. anyMatchingAttributes Examples Expression

 | Value

 | 
 ${allMatchingAttributes("[ax].*"):contains("world")}

 | true

 | 
 ${allMatchingAttributes(".*"):isNull()}

 | false

 | 
 ${allMatchingAttributes("f.*"):count()}

 | 1

 | 
 anyDelineatedValue

 Description: Splits a String apart according to a delimiter that is provided, and then evaluates each of the values against the rest of the Expression. If the Expression, when evaluated against any of the individual values, returns true, this function returns true. Otherwise, the function returns false.

 Subject Type: No Subject

 Arguments:

 • Delineated Value : The value that is delineated. This is generally an embedded Expression, though it does not have to be.

 • Delimiter : The value to use to split apart the delineatedValue argument.

 Return Type: Boolean

 Examples: Given that the "number_list" attribute contains the value "1,2,3,4,5", and the "word_list" attribute contains the value "the,and,or,not", consider the following examples:

 Table 35. anyDelineatedValue Examples Expression

 | Value

 | 
 ${anyDelineatedValue("${number_list}", ","):contains("5")}

 | true

 | 
 ${anyDelineatedValue("this that and", ","):equals("${word_list}")}

 | false

 | 
 allDelineatedValues

 Description: Splits a String apart according to a delimiter that is provided, and then evaluates each of the values against the rest of the Expression. If the Expression, when evaluated against all of the individual values, returns true in each case, then this function returns true. Otherwise, the function returns false.

 Subject Type: No Subject

 Arguments:

 • Delineated Value : The value that is delineated. This is generally an embedded Expression, though it does not have to be.

 • Delimiter : The value to use to split apart the delineatedValue argument.

 Return Type: Boolean

 Examples: Given that the "number_list" attribute contains the value "1,2,3,4,5", and the "word_list" attribute contains the value "those,known,or,not", consider the following examples:

 Table 36. allDelineatedValues Examples Expression

 | Value

 | 
 ${allDelineatedValues("${word_list}", ","):contains("o")}

 | true

 | 
 ${allDelineatedValues("${number_list}", ","):count()}

 | 5

 | 
 ${allDelineatedValues("${number_list}", ","):matches("[0-9]+")}

 | true

 | 
 ${allDelineatedValues("${word_list}", ","):matches('e')}

 | false

 | 
 join

 Description: Aggregate function that concatenates multiple values with the specified delimiter. This function may be used only in conjunction with the allAttributes, allMatchingAttributes, and allDelineatedValues functions.

 Subject Type: String

 Arguments:

 • Delimiter : The String delimiter to use when joining values

 Return Type: String

 Examples: Given that the "abc" attribute contains the value "hello world", "xyz" contains "goodbye world", consider the following examples:

 Table 37. join Examples Expression

 | Value

 | 
 ${allMatchingAttributes("[ax].*"):substringBefore(" "):join("-")}

 | hello-goodbye

 | 
 ${allAttributes("abc", "xyz"):join(" now ")}

 | hello world now goodbye world

 | 
 count

 Description: Aggregate function that counts the number of non-null, non-false values returned by the allAttributes, allMatchingAttributes, and allDelineatedValues. This function may be used only in conjunction with the allAttributes, allMatchingAttributes, and allDelineatedValues functions.

 Subject Type: Any

 Arguments: No arguments

 Return Type: Number

 Examples: Given that the "abc" attribute contains the value "hello world", "xyz" contains "good bye world", and "number_list" contains "1,2,3,4,5" consider the following examples:

 Table 38. count Examples Expression

 | Value

 | 
 ${allMatchingAttributes("[ax].*"):substringBefore(" "):count()}

 | 2

 | 
 ${allAttributes("abc", "xyz"):contains("world"):count()}

 | 1

 | 
 ${allDelineatedValues(${number_list}, ","):count()}

 | 5

 | 
 ${allAttributes("abc", "non-existent-attr", "xyz"):count()}

 | 2

 | 
 ${allMatchingAttributes(".*"):length():gt(10):count()}

 | 2

 | 
 Last updated 2025-07-19 14:22:31 +0200